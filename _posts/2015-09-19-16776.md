---
layout: post
title: 大きな行列から指定された文字列を探し出すには？
date: 2015-09-19 16:19:13
categories: ruby アルゴリズム
---
<!-- {% raw %} -->
<p>文章の一部を縦に読んだり横に読んだりすると、ある言葉が見つかることがあります。<br>
このことをより一般的に次のように考えることにします。</p>

<p>①文章（縦書きと横書きがありますが、ここでは横書きとします。）を<br>
　x×y行列に文字がおさまったもののように扱う。<br>
②行列の任意の場所から出発し、<strong>一つ右もしくは一つ下の文字をたどっていく。</strong><br>
　注）縦読みや横読みを含んでいますが、斜めに読むことは含んでいません。</p>

<p>さて、指定した文字列が見つかれば、<br>
"I found it!"<br>
を出力し、見つからなければ、<br>
"Not found"<br>
を出力するものとします。</p>

<p>次に示すコードでは、<br>
出発点から一つずつ順番に指定した文字列と一致する文字を探している<br>
のですが、<br>
xが大きくなっても指定された文字列を高速に探し出せるようにするには<br>
どうすればよろしいでしょうか？</p>

<pre><code># -*- coding: cp932 -*-

x = 10
y = 11
@num = (0..x * y - 1).to_a
# x×y行列（ただしy列目は番兵をおく）
ary1 = [
'あ', 'か', 'ま', 'き', 'が', 'み', 'ま', 'き', 'ま', 'き', '番兵',
'あ', 'か', 'き', 'が', 'み', 'あ', 'お', 'ま', 'き', 'が', '番兵',
'か', 'ま', 'ま', 'が', 'あ', 'か', 'ま', 'あ', 'ま', 'み', '番兵',
'あ', 'き', 'が', 'み', 'あ', 'お', 'ま', 'き', 'が', 'み', '番兵',
'き', 'か', 'ま', 'あ', 'お', 'か', 'ま', 'あ', 'み', 'き', '番兵',
'あ', 'か', 'ま', 'あ', 'ま', 'き', 'ま', 'あ', 'き', 'あ', '番兵',
'か', 'ま', 'き', 'あ', 'あ', 'か', 'ま', 'あ', 'ま', 'あ', '番兵',
'あ', 'か', 'が', 'あ', 'あ', 'か', 'ま', 'あ', 'き', 'あ', '番兵',
'あ', 'か', 'み', 'あ', 'あ', 'か', 'ま', 'あ', 'が', 'み', '番兵',
'あ', 'か', 'ま', 'お', 'ま', 'き', 'が', 'み', '。', '　', '番兵'
]
# ary1を一文字変更
ary2 = [
'あ', 'か', 'ま', 'き', 'が', 'み', 'ま', 'き', 'ま', 'き', '番兵',
'あ', 'か', 'き', 'が', 'み', 'あ', 'お', 'ま', 'き', 'が', '番兵',
'か', 'ま', 'ま', 'が', 'あ', 'か', 'ま', 'あ', 'ま', 'み', '番兵',
'あ', 'き', 'が', 'み', 'あ', 'お', 'ま', 'き', 'が', 'み', '番兵',
'き', 'か', 'ま', 'あ', 'お', 'か', 'ま', 'あ', 'み', 'き', '番兵',
'あ', 'か', 'ま', 'あ', 'ま', 'き', 'ま', 'あ', 'き', 'あ', '番兵',
'か', 'ま', 'き', 'あ', 'あ', 'か', 'ま', 'あ', 'ま', 'あ', '番兵',
'あ', 'か', 'が', 'あ', 'あ', 'か', 'ま', 'あ', 'き', 'あ', '番兵',
'あ', 'か', 'み', 'あ', 'あ', 'か', 'ま', 'あ', 'が', 'ま', '番兵',
'あ', 'か', 'ま', 'お', 'ま', 'き', 'が', 'み', '。', '　', '番兵'
]
ary3 = [
'あ', 'か', 'ま', 'き', 'が', 'み', 'ま', 'き', 'ま', 'き', '番兵',
'あ', 'か', 'き', 'が', 'み', 'あ', 'お', 'ま', 'き', 'が', '番兵',
'か', 'ま', 'ま', 'が', 'あ', 'か', 'ま', 'あ', 'ま', 'み', '番兵',
'あ', 'き', 'が', 'み', 'あ', 'お', 'ま', 'き', 'が', 'み', '番兵',
'き', 'か', 'ま', 'あ', 'お', 'ま', 'き', 'が', 'み', 'き', '番兵',
'あ', 'か', 'ま', 'あ', 'ま', 'き', 'が', 'あ', 'き', 'あ', '番兵',
'か', 'ま', 'き', 'あ', 'あ', 'が', 'み', 'き', 'ま', 'あ', '番兵',
'あ', 'か', 'が', 'あ', 'あ', 'み', 'き', 'ま', 'き', 'あ', '番兵',
'あ', 'か', 'み', 'あ', 'あ', 'か', 'ま', 'き', 'が', 'ま', '番兵',
'あ', 'か', 'ま', 'お', 'ま', 'き', 'が', 'が', '。', '　', '番兵'
]

def search(ary, i, str_ary, str)
  i_ary = []
  str_ary.each{|m|
    # strを右と下から探す
    ([m + 1, m + i] &amp; @num).each{|n|
      i_ary.push(n) if ary[n] == str
    }
  }
  i_ary
end

def find_the_word(ary, i, str)
  str_size = str.size
  message = 'Not found'
  @num.each{|x|
    if ary[x] == str[0]
      s = 1
      next_a = search(ary, i, [x], str[s])
      while next_a.size &gt; 0 &amp;&amp; s &lt; str_size - 1
        a = next_a
        s += 1
        next_a = search(ary, i, a, str[s])
      end
      if next_a.size &gt; 0 &amp;&amp; s == str_size - 1
        message = 'I found it!'
        break
      end
    end
  }
  message
end

p 'ary1'
p find_the_word(ary1, y, 'あかまきがみあおまきがみきまきがみ')
p 'ary2'
p find_the_word(ary2, y, 'あかまきがみあおまきがみきまきがみ')
p 'ary3'
p find_the_word(ary3, y, 'あかまきがみあおまきがみきまきがみ')
</code></pre>

<p>出力結果<br>
"ary1"<br>
"I found it!"<br>
"ary2"<br>
"Not found"<br>
"ary3"<br>
"Not found"</p>

<p>（追記）<br>
「xが大きくなっても指定された文字列を高‌​速に探し出せるようにする」とありますが、具体的にどれくらいの大きさのものをどれくらいのスピードで探し出したいのか、具体的なゴールはありますか？ <br>
に対する回答ですが、<br>
xが1000位でも必ず１秒以内で結果が出力される<br>
ように変更したいです。<br>
現状だと、（x = 1010 に変更し、）<br>
ary2を100回繰り返したものにary1を加えたものに対して、<br>
"I found it!"と表示されるまで１秒もかからないのに対し、<br>
ary3を100回繰り返したものにary1を加えたものに対して、<br>
"I found it!"と表示されるまで何分も待たないといけません。</p>
<!-- {% endraw %} -->
