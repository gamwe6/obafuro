---
layout: post
title: Cygwinのg++で毎回、実行時に変数のアドレスが一緒になるのは何故？
date: 2015-08-12 18:25:38
categories: c++ cygwin
---
<!-- {% raw %} -->
<p>特に困っているわけではないのですが、素朴な疑問として、<br>
Cygwinのg++で次のコードを実行すると、Cygwinだけが毎回同じアドレスを表示します。<br>
そもそもOSは仮想アドレッシングをしていて、<br>
実際の物理アドレスとは違う値を表示しているのは理解していますが、<br>
Windows(MSVC)/CentOS(g++)/Ubuntu(g++)で下記コードを実行すると<br>
毎回違うアドレスを表示するのですが、<br>
Cygwinのg++だけ何度実行しても同じアドレスを表示します。<br>
どうしてこのような結果になるのかご教示いただけないでしょうか。<br>
さらに不思議なことにprintf("%p\n", ...)の結果が<br>
Cygwinでのみ6桁で表示されるのですが(他は8桁、CentOSの64bit版の場合は12桁)、これもなぜなのかわかりません。</p>

<pre><code>#include &lt;cstdio&gt;

int main()
{
    int c = 1;
    int *a;
    int &amp;b = c;
    a = &amp;c;

    printf("変数に格納されている値\n");
    printf("a: %d\n", *a);
    printf("b: %d\n", b);
    printf("c: %d\n", c);
    printf("アドレス\n");
    printf("a: %p\n", a);
    printf("b: %p\n", &amp;b);
    printf("c: %p\n", &amp;c);

    getchar(); // 一時停止

    return 0;
}
</code></pre>

<p>実行結果例(MSVC)</p>

<pre><code>変数に格納されている値
a: 1
b: 1
c: 1
アドレス
a: 007EF940
b: 007EF940
c: 007EF940
</code></pre>

<p>※アドレスの値の先頭に0xが付くなどはどうもコンパイラ依存のようです。<br>
プログラム毎に独立したメモリ空間を使うため、毎回アドレスが変わると思っていたのですが、<br>
Cygwinのみが同じアドレスを指します。</p>

<p>ちなみに、<code>static int c = 1;</code>とすればどの環境でも毎回、アドレスは同一になります。<br>
ひょっとするとこのような質問はstackoverflow的には好ましくないのかもしれません……。</p>

<p><strong>回答を得た後の追記</strong><br>
<strong><em>質問する時点では知らなかったのですが、セキュリティ対策がなしの設定ではどのコンパイラ(もっと正確にいうと処理系)も毎回同じアドレスになる、というのが普通です。Cygwin以外が本当は通常と異なる動きをしていました（ASLR等のセキュリティ対策がON）</em></strong><br>
また、私自身の質問が混乱した記述になっていますが、同じアドレスから通常は始まる理由は<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E7%A9%BA%E9%96%93" rel="nofollow noreferrer">アドレス空間</a>によると、</p>

<blockquote>
  <p>ユーザ空間または「ユーザー仮想アドレス空間」はユーザープロセスの動作するアドレス空間である。コンピュータシステム上で動作する各プロセスは、それに対応するデータとコードを持ち、実行中にはそれらがユーザ空間上にロードされる。ユーザ空間はプロセス毎に割り当てられ、それぞれのアドレス範囲は同じである。従って、仮想記憶方式のオペレーティングシステムでは、ユーザープログラムのコードやデータは同じアドレスから開始されるようになっていることが多い。</p>
</blockquote>

<p>とのことです。</p>
<!-- {% endraw %} -->
