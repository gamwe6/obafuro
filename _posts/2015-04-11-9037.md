---
layout: post
title: swiftでprotocolが入ったframeworkを作りたい
date: 2015-04-11 02:37:56
categories: swift xcode6 playframework delegate
---
<!-- {% raw %} -->
<p>お世話になります<br>
タイトルの通り、swiftでprotocolの入ったframeworkを作りたいと考えております<br>
が、現在詰まっておりまして、framework自体はできたのですが、protocolがheaderファイルに見えてない状態でして、実質使えないという状態になって困っております</p>

<pre><code>      //
  //  ConnectionBySession.swift
  //  ShotAlertForSwift
  //
  //  Created by 平塚 俊輔 on 2015/04/07.
  //  Copyright (c) 2015年 &amp;#24179;&amp;#22618;&amp;#12288;&amp;#20426;&amp;#36628;. All rights reserved.
  //

  protocol ConnectionResultBySession{
      func showResult(resultMessage: String?) -&gt; Void
      func handleErrorForConnection()
  }

  public class ConnectionBySession : NSObject,NSURLSessionDataDelegate{

      // 参考:
      // NSURLConnection ttp://stackoverflow.com/questions/24176362/ios-swift-and-nsurlconnection
      // Delegate, Protocol ttp://qiita.com/mochizukikotaro/items/a5bc60d92aa2d6fe52ca

      // nilが入ってるなんてあり得ない！
      var urlStr : String
      var data : NSMutableData? = nil
      var delegate : ConnectionResultBySession!
      var error:NSError?
      var status:Int?
      var session:NSURLSession!

      // コンストラクタ
      public init(urlStr: String) {
          self.data = NSMutableData()
          self.urlStr = urlStr
      }

      // アクセス
      public func doConnect() -&gt; Void{
          println(urlStr)
          var url : NSURL = NSURL(string: urlStr)!

          //タイムアウトは15秒
          var config = NSURLSessionConfiguration.defaultSessionConfiguration()
          config.timeoutIntervalForRequest = 15
          //
          self.session = NSURLSession(configuration: config,
              delegate: self,
              delegateQueue: NSOperationQueue.mainQueue())

          var task:NSURLSessionDataTask = self.session.dataTaskWithURL(url)
          task.resume()
      }

      public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveResponse response: NSURLResponse, completionHandler: (NSURLSessionResponseDisposition) -&gt; Void){
          println("request_start")

          if response.isKindOfClass(NSHTTPURLResponse){
              let httpURLResponse:NSHTTPURLResponse = response as NSHTTPURLResponse

              self.status = httpURLResponse.statusCode


              if self.status == 200{
                  //println("success")

                  let disposition:NSURLSessionResponseDisposition = NSURLSessionResponseDisposition.Allow
                  completionHandler(disposition)
              }else{
                  self.delegate.handleErrorForConnection()
              }
          }


      }
      public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask){
          println("didBecomeDownloadTask")
      }

      public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData){

          //        let json : String = NSString(data: data, encoding: NSUTF8StringEncoding)!
          //        println(json)


          self.data!.appendData(data)
          self.delegate.showResult("success")



      }

      public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?){
          println(error)
          if error != nil{
              //println("didCompleteWithError")
              self.delegate.handleErrorForConnection()
          }


      }
      public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?){
          println(error)

          if error != nil{
              //println("didCompleteWithError")
              self.delegate.handleErrorForConnection()
          }
      }

      func cancelConnect(){
          self.session.getTasksWithCompletionHandler
              {
                  (dataTasks, uploadTasks, downloadTasks) -&gt; Void in

                  self.cancelTasksByUrl(dataTasks     as [NSURLSessionTask])

          }
      }

      private func cancelTasksByUrl(tasks: [NSURLSessionTask])
      {
          for task in tasks
          {
              task.cancel()
          }
      }
  }
</code></pre>

<p>というファイルでframeworkを作り、ビルドは通ったのですが、実際に作られてる、frameworkのヘッダファイルを見ると</p>

<pre><code>          // Generated by Swift version 1.1 (swift-600.0.57.4)
      #pragma clang diagnostic push

      #if defined(__has_include) &amp;&amp; __has_include(&lt;swift/objc-prologue.h&gt;)
      # include &lt;swift/objc-prologue.h&gt;
      #endif

      #pragma clang diagnostic ignored "-Wauto-import"
      #include &lt;objc/NSObject.h&gt;
      #include &lt;stdint.h&gt;
      #include &lt;stddef.h&gt;
      #include &lt;stdbool.h&gt;

      #if defined(__has_include) &amp;&amp; __has_include(&lt;uchar.h&gt;)
      # include &lt;uchar.h&gt;
      #elif !defined(__cplusplus) || __cplusplus &lt; 201103L
      typedef uint_least16_t char16_t;
      typedef uint_least32_t char32_t;
      #endif

      typedef struct _NSZone NSZone;

      #if !defined(SWIFT_PASTE)
      # define SWIFT_PASTE_HELPER(x, y) x##y
      # define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
      #endif
      #if !defined(SWIFT_METATYPE)
      # define SWIFT_METATYPE(X) Class
      #endif

      #if defined(__has_attribute) &amp;&amp; __has_attribute(objc_runtime_name)
      # define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
      #else
      # define SWIFT_RUNTIME_NAME(X)
      #endif
      #if !defined(SWIFT_CLASS_EXTRA)
      # define SWIFT_CLASS_EXTRA
      #endif
      #if !defined(SWIFT_PROTOCOL_EXTRA)
      # define SWIFT_PROTOCOL_EXTRA
      #endif
      #if !defined(SWIFT_CLASS)
      # if defined(__has_attribute) &amp;&amp; __has_attribute(objc_subclassing_restricted) 
      #  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
      # else
      #  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
      # endif
      #endif

      #if !defined(SWIFT_PROTOCOL)
      # define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
      #endif

      #if !defined(SWIFT_EXTENSION)
      # define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
      #endif

      #if !defined(OBJC_DESIGNATED_INITIALIZER)
      # if defined(__has_attribute) &amp;&amp; __has_attribute(objc_designated_initializer)
      #  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
      # else
      #  define OBJC_DESIGNATED_INITIALIZER
      # endif
      #endif
      #if defined(__has_feature) &amp;&amp; __has_feature(modules)
      @import ObjectiveC;
      @import Foundation.NSURLSession;
      #endif

      #pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
      #pragma clang diagnostic ignored "-Wduplicate-method-arg"
      @class NSURLSession;
      @class NSURLSessionDataTask;
      @class NSURLResponse;
      @class NSURLSessionDownloadTask;
      @class NSData;
      @class NSURLSessionTask;
      @class NSError;

      SWIFT_CLASS("_TtC19ConnectionBySession19ConnectionBySession")
      @interface ConnectionBySession : NSObject &lt;NSURLSessionDataDelegate&gt;
      - (instancetype)initWithUrlStr:(NSString *)urlStr OBJC_DESIGNATED_INITIALIZER;
      - (void)doConnect;
      - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler;
      - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask;
      - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data;
      - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error;
      - (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(NSError *)error;
      @end

      #pragma clang diagnostic pop
</code></pre>

<p>あれ、protocolは何処へ。。。<br>
当然使おうとしても、delegateがないよと怒られてしまいます</p>

<p>調べてるのですが、解決策が見つからず。。。<br>
どうしたらよいかお分かりになる方いらっしゃいますでしょうか<br>
よろしくお願いします。</p>
<!-- {% endraw %} -->
