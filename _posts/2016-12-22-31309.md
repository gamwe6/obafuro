---
layout: post
title: "マルチコアCPUにおけるプロセス間共有メモリについて"
date: 2016-12-22 04:36:25
categories: linux windows
---
<p>マルチコアCPU環境でのプロセス間共有メモリについての疑問です。</p>

<p>まずマルチコアCPUの構造として</p>

<pre>
    +----------+ +----------+
    |  コア1   | |  コア2    |
    +----------+ +----------+
    |キャッシュ | |キャッシュ |
    +----------+-+----------+
    |        メモリ          |
    +-----------------------+
</pre>

<p>というように、コアごとにキャッシュがあります。</p>

<p>ここで２つのアプリケーション(App1とApp2)の間用の共有メモリを考えます。<br>
App1がコア1で動作、App2がコア2で動作するとします。</p>

<p>何も考えなければApp1が共有メモリに書き込んだとしても、<br>
App2にはその内容を読み取れない可能性があります。</p>

<p>App1が書き込んだ内容は、まだコア1のキャッシュにとどまっている場合もあれば、<br>
たとえメモリに書き込まれたとしてもコア2のキャッシュに充てんされていないかもしれません。</p>

<p>この問題を解消するための方策として、次の2つが考えられます。<br>
1. キャッシュを通さずにメモリに書いて、キャッシュを通さずメモリから読みだす<br>
2. キャッシュを通すがあるまとまった単位でキャッシュからメモリに書き込んで、<br>
読み込む場合は、メモリからキャッシュに充てんする。</p>

<p>1の方策は遅いですが、なにも考えずにできます。<br>
2の方策は速いですが、キャッシュ操作が必要になります。</p>

<h1>質問：</h1>

<p>Windows, Linuxで実際のところはどうなっているのか？</p>

<h2>Windowsでの方策1</h2>

<p>CreateFileMapping()でflProtect引数に</p>

<p>A.SEC_NOCACHEを指定した場合にのみ<br>
　キャッシュを通さずメモリに直接アクセスされる。<br>
B.指定しなくても<br>
　キャッシュを通さずメモリに直接アクセスされる。<br>
C.その他</p>

<p>のいずれでしょうか？</p>

<h2>Windowsでの方策2</h2>

<p>CreateFileMapping()でflProtect引数にSEC_NOCACHEを指定しないとキャッシュ経由になる？<br>
キャッシュからメモリへの書き込み、メモリからキャッシュへの充てんは<br>
FlushViewOfFile()を使う？</p>

<h2>Linuxでの方策1</h2>

<p>mmap()またはshm_open()で返されるアドレスへのアクセスは<br>
常にキャッシュを通さずにメモリに書いて、キャッシュを通さずメモリから読みだす？</p>

<h2>Linuxでの方策2</h2>

<p>mmap()またはshm_open()で返されるアドレスへのアクセスは常にキャッシュ経由のアクセスで、<br>
キャッシュからメモリへの書き込み、メモリからキャッシュへの充てんはmsync()を使う？</p>
