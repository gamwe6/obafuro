---
layout: post
title: ラッパークラスの単体テストの方法
date: 2017-05-22 06:08:54
categories: テスト
---
<p>ラッパークラスを作っています。<br>
このラッパークラスはクラスAを簡単に使うためのものとします。<br>
ラッパークラスのユニットテストをしたいです。</p>

<p>ラッパークラスを使う側はクラスAの使い方や中の実装を意識しないのでテストもクラスAを意識しないものになるはずです。<br>
しかしそれを守りながら作っていたらラッパークラスのテストケースが複雑になってきてしまいました。<br>
ラッパークラスのメソッドのテストで使うテストケースや条件の準備が膨れ上がってしまいました。</p>

<p>これはラッパークラスが責任を持ちすぎなように感じクラス(デリゲート)を分離しようとしましたがそのデリゲートを外から入れるという操作はしたくありません。</p>

<p>このデリゲートは別でテストをして、ラッパークラスをテストする時はデリゲートのモックを使うというようにすればテストも簡潔に済みそうですが、プライベートのデリゲートを外見の振る舞いのようにモックに付けるというのは何か間違っている気がします。</p>

<p>こういった場合に使われるパターンや考え方を教えていただきたいです。<br>
そもそもラッパークラスをテストする必要自体がないのでしょうか？</p>

<hr>

<p>追記</p>

<p>コメントありがとうございます。一緒に作っている人がいるのでコードは直接は載せられませんが詳しく書きます。<br>
拙い説明なので足りないところがありましたら追記していきます。</p>

<p>似たようなwebhookリクエストを受け取って似たようなWeb上のAPIを呼ぶということを共通に行うためのラッパークラスを作っています。その際テストからコードを書くということの勉強をしていました。<br>
ラッパークラスは使うAPIの種類をコンストラクタで指定してどのAPIのためのラッパーとして動くのかを決めます。</p>

<p>PHPとPHPUnitを使っています。</p>

<p>ラッパークラス</p>

<pre><code>class APIWrapper {

  private $api;

  public function __construct($type) {
    switch($type) {
      // APIの種類ごとに初期化処理をします
      case 'hoge':
      $this-&gt;api = new HogeAPI($a, $b, $c);
      break;
      // ここ以外のラッパーのメソッドなどにも登場する分岐を
      // Hoge用の設定・処理、Fuga用の設定・処理とクラスに分けて
      // それらを別クラスに作ってもらい同じインタフェースで使うという方法を
      // 最終的には取っていきたいですが、これも中にあるものなのでラッパーではプライベートです
    }
    // 各APIのクラスの中でグローバル変数を使うことがあります、リクエストヘッダを見たりもします
    // このリクエストヘッダの設定やリクエストボディの設定がテスト時に厄介です
    if (!$this-&gt;api-&gt;validate()) {
      throw new UnexpectedValueException('ヘッダがおかしいです。');
    }
  }

}
</code></pre>

<p>テストクラス</p>

<pre><code>class APIWrapperTest extends PHPUnit\Framework\TestCase {

  public function testInitialize() {
    // ここでリクエストヘッダやグローバル変数を設定します
    // リクエストヘッダを読み込んだりするクラスを別で用意すれば
    // それをどこかのコンストラクタで引数に渡すということもできそうですが最終的にはラッパーなので隠したいです
    $file_get_contents_rtv = 'file_get_contentsの戻り値を上書き';
    $_SERVER['X_HOGE'] = 'dummy';
    $wrapper = new APIWrapper();
  }

}
</code></pre>
