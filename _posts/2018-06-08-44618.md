---
layout: post
title: "x86アーキテクチャにおけるリアルモードからプロテクトモードへの移行について"
date: 2018-06-08 09:02:35
categories: アセンブリ言語 x86
---
<p>現在、「作りながら学ぶOSカーネル 保護モードプログラミングの基本と実践」という本でOSについて学んでいます。</p>

<p>そこで、x86について、リアルモードから保護モードへ移行する際にCR0の最下位ビット（PEビット）を1にすることでCPUが保護モードとして動作するようになるという記載がありました。<br>
しかし、その後の32ビットコード部分へのfarジャンプ命令では、prefix（0x66, 0x67）をつけているようです。</p>

<p>CPUはすでに保護モード（32ビット）として動いているはずなので、オペランドを32ビットと解釈させるためのprefixは不要と思えるのですが、なぜ必要となるのでしょうか？<br>
確かに、prefixを外して実行するとうまくいきませんでした。</p>

<p>実際に本で説明されていた移行部分のコードは下記となります。</p>

<pre><code>mov eax, cr0
or eax, 0x00000001
mov cr0, eax

jmp $+2
nop
nop

db 0x66    # &lt;- ここ
db 0x67    # &lt;- ここ
db 0xEA
dd PM_Start
dw SysCodeSelector
</code></pre>

<p>また、PEビットを1にした時点で保護モードとしてCPUが動作するのであれば、<br>
その直後の命令ポインタが指すアドレスがくるってしまう気がするのですが、そんなことはないのでしょうか。</p>

<p>というのも、保護モードではCSレジスタの値からGDTを参照して対象のセグメントを探し出し、<br>
EIPレジスタに入っているオフセットを足して次の命令をフェッチしていると思うのですが、<br>
PEビットを1にした直後はCSレジスタにはリアルモードで使用していたセグメント情報が入っており、<br>
それを元にGDTを参照しようとするとわけのわからないところを参照してしまいそうな気がしました。</p>
