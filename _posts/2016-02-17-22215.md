---
layout: post
title: pollを用いた際のサーバプログラムでクライアントの識別
date: 2016-02-17 13:09:25
categories: linux c
---
<!-- {% raw %} -->
<p>pollを用いた際のサーバプログラムでクライアントの識別方法が知りたいです。<br>
UDPパケットを多数のクライアントから受け付けるサーバを書きました。パケットは多数のクライアントから順不同に到着します。<br>
クライアントを識別するために新しいパケットが到着するとクライアントの識別子をふって配列に追加します。</p>

<p>これによりいつでもクライアントの情報を書き換えられます。<br>
しかし、クライアント側の制約でクライアントの識別子はクライアントサイドからは送信できません。よってUDPなのにもかかわらずクライアントをいちいち識別しないといけません。</p>

<p>そこでpollで書き込みを検知した場合に内部でループを回し，クライアントが使用をやめる(仕様をやめたらクライアントの配列から消しても大丈夫な仕様なので)とループを抜ける<br>
といった感じにしようかなと思いました。<br>
ここで疑問なのですが</p>

<pre><code>for(;;){
 int count = 0;
 targets[count].fd = soc;//socket
 targets[count].events = POLLIN;
 count++;
 for(int i=0;i &lt; child_no;i++){
  if(child[i] != -1){
   targets[count.fd = child[i];
   target[count].events = POLLIN;
   count++;
  }
 }
 switch(poll(targets, count, 10 * 1000)) {
  case -1:break;
  case 0:break;
  default:
   if(targets[0].revents &amp; POLLIN){
    /*ここでクライアントとのセッション管理をしないといけない、クライアントのUDPパケットとクライアントの対応付けができないといけない、しかしクライアント側から識別子は送れない、そこでここで無限ループを回せばいいのではないか?*/
    break;
   }
 }
}
</code></pre>

<p>上の日本語を書いた場所において無限ループを回し，受信待ちを実行した場合マルチクライアント対応はできるのか？シングルプロセスだし　マルチクライアント対応できないのではないか<br>
が疑問です。<br>
教えていただきたいです。もし無理な場合は解決策も教えていt抱けるとありがたいです。</p>
<!-- {% endraw %} -->
