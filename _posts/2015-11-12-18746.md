---
layout: post
title: "「nをk個の相異なる数に分割する」場合の数を高速に求めるには？"
date: 2015-11-12 13:52:46
categories: ruby アルゴリズム haskell
---
<p>「nをk個の相異なる数に分割する」場合の数をf(n, k)とします。</p>

<p>例えば、10 = 1 + 2 + 7 = 1 + 3 + 6 = 1 + 4 + 5 = 2 + 3 + 5<br>
なので、f(10, 3) = 4です。</p>

<p>f(n, k)を高速に求めるにはどのようにすればよろしいでしょうか？</p>

<p>以下大変遅いコードです。</p>

<pre><code># nをk個の相異なる数（最大値がl）に分割
def g(n, l, k)
  return 1 if n == l &amp;&amp; k == 1
  # 末尾がiのものにlを追加
  (1..l - 1).inject(0){|s, i| s += g(n - l, i, k - 1)}
end

# nをk個の相異なる数に分割
def f(n, k)
  (1..n).inject(0){|s, l| s += g(n, l, k)}
end

# 以下検証のためp(n | 和因子は相異なる)を求めてみる
def A000009(n)
  return 1 if n == 0
  (1..n).inject(0){|s, k| s += f(n, k)}
end
p (0..20).map{|i| A000009(i)}
</code></pre>

<p>実行結果<br>
[1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15, 18, 22, 27, 32, 38, 46, 54, 64]<br>
（p(n | 和因子は相異なる)については、<a href="https://ja.stackoverflow.com/questions/9548/%E3%82%AA%E3%82%A4%E3%83%A9%E3%83%BC%E3%81%AE%E5%88%86%E5%89%B2%E6%81%92%E7%AD%89%E5%BC%8F%E3%82%92%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%A7%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%AB%E3%81%AF">オイラーの分割恒等式をプログラミングで確認するには？</a> で質問しました。）</p>
