---
layout: post
title: "DEAPにおける出力結果の詳細について"
date: 2015-12-12 09:51:04
categories: python
---
<p>GAを用いて最適化する必要がありその為にpythonのモジュールの1つであるDEAPを使っています。<br>
試しとしてExampleのナップサック問題を実装しました。<br>
<a href="https://github.com/DEAP/deap/blob/a2765c3344cb834f47eaab22efbb961e18f4aed7/examples/ga/knapsack.py" rel="nofollow">https://github.com/DEAP/deap/blob/a2765c3344cb834f47eaab22efbb961e18f4aed7/examples/ga/knapsack.py</a></p>

<p>そこで質問なのですが、このコードを実装した時に出力されるstdやmin、maxの中身はどのように見ればよろしいのでしょうか。</p>

<p>自分の理解としては、maxはあるリストを与えた時にそのリスト内の最大値を返すものだと思っており、そのためにDEAPモジュール内にあるalgorithmsに</p>

<pre><code>def eaMuPlusLambda(population, toolbox, mu, lambda_, cxpb, mutpb, ngen,
                   stats=None, halloffame=None, verbose=__debug__):
    """This is the :math:`(\mu + \lambda)` evolutionary algorithm.

    :param population: A list of individuals.
    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution
                    operators.
    :param mu: The number of individuals to select for the next generation.
    :param lambda\_: The number of children to produce at each generation.
    :param cxpb: The probability that an offspring is produced by crossover.
    :param mutpb: The probability that an offspring is produced by mutation.
    :param ngen: The number of generation.
    :param stats: A :class:`~deap.tools.Statistics` object that is updated
                  inplace, optional.
    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will
                       contain the best individuals, optional.
    :param verbose: Whether or not to log the statistics.
    :returns: The final population
    :returns: A class:`~deap.tools.Logbook` with the statistics of the
              evolution.

    The algorithm takes in a population and evolves it in place using the
    :func:`varOr` function. It returns the optimized population and a
    :class:`~deap.tools.Logbook` with the statistics of the evolution. The
    logbook will contain the generation number, the number of evalutions for
    each generation and the statistics if a :class:`~deap.tools.Statistics` is
    given as argument. The *cxpb* and *mutpb* arguments are passed to the
    :func:`varOr` function. The pseudocode goes as follow ::

        evaluate(population)
        for g in range(ngen):
            offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)
            evaluate(offspring)
            population = select(population + offspring, mu)

    First, the individuals having an invalid fitness are evaluated. Second,
    the evolutionary loop begins by producing *lambda_* offspring from the
    population, the offspring are generated by the :func:`varOr` function. The
    offspring are then evaluated and the next generation population is
    selected from both the offspring **and** the population. Finally, when
    *ngen* generations are done, the algorithm returns a tuple with the final
    population and a :class:`~deap.tools.Logbook` of the evolution.

    This function expects :meth:`toolbox.mate`, :meth:`toolbox.mutate`,
    :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be
    registered in the toolbox. This algorithm uses the :func:`varOr`
    variation.
    """
    logbook = tools.Logbook()
    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])

    # Evaluate the individuals with an invalid fitness
    invalid_ind = [ind for ind in population if not ind.fitness.valid]
    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
    for ind, fit in zip(invalid_ind, fitnesses):
        ind.fitness.values = fit

    if halloffame is not None:
        halloffame.update(population)

    record = stats.compile(population) if stats is not None else {}
    logbook.record(gen=0, nevals=len(invalid_ind), **record)
    if verbose:
        print logbook.stream

    # Begin the generational process
    for gen in range(1, ngen + 1):
        # Vary the population
        offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)

        # Evaluate the individuals with an invalid fitness
        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit

        # Update the hall of fame with the generated individuals
        if halloffame is not None:
            halloffame.update(offspring)

        # Select the next generation population
        population[:] = toolbox.select(population + offspring, mu)

        # Update the statistics with the new population
        record = stats.compile(population) if stats is not None else {}
        logbook.record(gen=gen, nevals=len(invalid_ind), **record)
        if verbose:
            print logbook.stream
        import pdb
        pdb.set_trace()

    return population, logbook
</code></pre>

<p>とpdbをいれて実行し、p　populationと実行しましたがよくわからないリストが出されるのみで上手くいきませんでした。</p>

<p><strong>追記</strong><br>
populationがどのような個体から計算されているか見ることは出来ませんか？<br>
例えばMAXでは[  49.　　865.83549407] と算出されてきますが、それがどのような個体の組合せで算出されているのでしょうか。</p>

<p>現在、私は[1 40][3 60]・・・・・のような個体の組合せで算出されると認識しております。<br>
そのためにitemsの中身をみればよいと考え以下の様にコードを変えてみましたがpopulationで算出された1個目ととこれで計算した中身の1個目との計算が合わず上手く行きませんでした。</p>

<pre><code>def evalKnapsack(individual):
    weight = 0.0
    value = 0.0
    for item in individual:
        weight += items[item][0]
        value += items[item][1]
        print items[item][0]
        print items[item][1]
    if len(individual) &gt; MAX_ITEM or weight &gt; MAX_WEIGHT:
        return 10000, 0   

    return weight, value
</code></pre>

<p>何卒、よろしくお願いします。</p>
