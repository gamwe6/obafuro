---
layout: post
title: READ UNCOMMITTED をむしろ使いたい状況？
date: 2016-01-25 04:10:16
categories: sql mariadb
---
<p>私のサーバーシステムでは READ UNCOMMITTED をむしろ使用したいような状況が発生致しました。<br>
私の考えは正しいでしょうか？</p>

<p>掲示板アプリのサーバーにて、掲示板に投稿したとして以下の処理が発生します。</p>

<ul>
<li>トランザクション

<ul>
<li>トークテーブルに投稿を格納（insert）</li>
<li>掲示板テーブルの　トータル投稿数更新（サブクエリではなくcount:=count+１で）　と　最終投稿時間を更新（update）</li>
<li>掲示板テーブルから　トータル投稿数　をセレクト（select）</li>
</ul></li>
<li>このトランザクション実行後、３番めのSQLで取得した投稿数が１０００未満ならコミット<br>
そうではないならロールバック（投稿失敗）</li>
</ul>

<p>要するに、投稿格納後に投稿数上限の１０００を超えていないかのチェックを行います。<br>
一見、 SERIALIZABLE がいいように思えますが（もちろんそうなのですが）<br>
処理性能のことも考えると、むしろここは一番最弱な READ UNCOMMITTED を使用したほうがいい気がしてきました。</p>

<p>READ UNCOMMITTED なら<br>
２つの投稿トランザクションが同時に処理された場合、どちらかが先に２つめのSQLを実行した時点で、もう片方はトランザクション中に３番めのSQLにてそのコミットされていない値を取得して、<br>
最大投稿数以上投稿してしまうことを防げると思ったからです。</p>

<p>この場合、上記の場合は</p>

<ul>
<li>２つとも投稿処理が失敗する可能性（お互い、更新後にセレクトしたら）<br>
　→　そのぐらいべつにおｋ</li>
<li>最新投稿時間がもう片方の投稿の時間になる可能性（セレクト順だけ逆転する）<br>
　→　とは言えど、同時に発生した処理のためその差は数ミリ秒程度なのでおｋ</li>
<li>片方だけロールバック発生したらカウントがおかしくなることがある（現在インクリメント系　count=count+1なので）<br>
　→　重要な不具合なのですがそもそもこのカラムをなくし、毎回取得時にカウントすることにする</li>
</ul>

<p>が発生するかと思われますが、それは妥協とします。<br>
このようにあえて　READ UNCOMMITTED　の弱点を利用するってのはやめるべきでしょうか？</p>
